{"name":"Mongothon","tagline":"A lightweight Mongo object-document mapping abstraction layer over PyMongo","body":"# Mongothon\r\n\r\nMongothon is a MongoDB object-document mapping API for Python, loosely based on the awesome [mongoose.js](http://mongoosejs.com/) library.\r\n\r\n[![build status](https://travis-ci.org/tleach/mongothon.png?branch=master \"Build status\")](https://travis-ci.org/tleach/mongothon)\r\n\r\n# Installation\r\n\r\nInstall via easy_install:\r\n```\r\neasy_install mongothon\r\n```\r\nOr, via pip:\r\n```\r\npip install mongothon\r\n```\r\n\r\n# Getting Started\r\n\r\nMongothon allows you to declaratively express the structure and contraints of your Mongo document in a reusable Schema using Python dicts. Schemas can then be used to generate reusable Model classes which can be used in your application to perform IO with your associated Mongo collection.\r\n\r\n## Example\r\n\r\nDefine the Mongo document structure and constraints in a Schema:\r\n```python\r\ncar_schema = Schema({\r\n    \"make\":         {\"type\": basestring, \"required\": True},\r\n    \"model\":        {\"type\": basestring, \"required\": True},\r\n    \"num_wheels\":   {\"type\": int,        \"default\": 4, \"validates\": gte(0)}\r\n    \"color\":        {\"type\": basestring, \"validates\": one_of(\"red\", \"green\", \"blue\")}\r\n})\r\n```\r\n\r\nGenerate a reusable model class from the Schema and pymongo collection:\r\n```python\r\nCar = create_model(car_schema, db['car'])\r\n```\r\n\r\nFind, modify and save a document:\r\n```python\r\ncar = Car.find_by_id(some_id)\r\ncar['color'] = \"green\"\r\ncar.save()\r\n```\r\n\r\nCreate a new document:\r\n```python\r\ncar = new Car({\r\n    \"make\":     \"Ford\",\r\n    \"model\":    \"F-150\",\r\n    \"color\":    \"red\"\r\n})\r\ncar.save()\r\n```\r\n\r\nRemove a document\r\n```python\r\ncar.remove()\r\n```\r\n\r\nValidate a document\r\n```python\r\ncar = new Car({\r\n    \"make\":         \"Ford\",\r\n    \"model\":        \"F-150\",\r\n    \"num_wheels\":   -1\r\n    \"color\":        \"red\"\r\n})\r\n\r\ntry:\r\n    car.validate()\r\nexcept ValidationException:\r\n    # num_wheels should be >= 0\r\n\r\n```\r\n\r\n# API Reference\r\n\r\n## Schemas\r\n\r\n### Types\r\n\r\nEach field in a Mongothon schema must be given a type by adding a `\"type\"` key to the field spec dict. For example, this schema declares a single `\"name\"` field with a type of `basestring`:\r\n```python\r\nschema = Schema({\"name\": {\"type\": basestring}})\r\n```\r\nSupported field types are: `basestring`, `int`, `float`, `datetime`, `long`, `bool`, `Schema` (see Nested schemas below) and `Mixed`.\r\n\r\n#### The \"Mixed\" type\r\nThe `Mixed` type allows you to indicate that a field supports values of multiple types. Use of this type is generally not encouraged (consistent field typing makes life easier) but is sometimes necessary.\r\n`Mixed` can be provided as a class to indicate a value of any supported type may be used in a given field:\r\n```python\r\nschema = Schema({\"misc\": {\"type\": Mixed}})  # all types are valid in this field\r\n```\r\nYou can also instantiate `Mixed` with a list of sub-types to indicate that a value of one of a subset of supported types may be used in the field:\r\n```python\r\nschema = Schema({\"external_id\": {\"type\": Mixed(basestring, int, ObjectId)}})  # only basestring, int and ObjectId are supported\r\n```\r\n\r\nIf you attempt to save a model containing a value of the wrong type for a given a field a `ValidationException` will be thrown.\r\n\r\n### Mandatory fields\r\nYou can require a field to be present in a document by adding `\"required\": True` to the Schema:\r\n```python\r\nschema = Schema({\"name\": {\"type\": basestring, \"required\": True}})\r\n```\r\nBy default all fields are not required.\r\nIf `save()` is called on model which does not contain a value for a required field then the model will raise a `ValidationException`.\r\n\r\n### Defaults\r\nSchemas allow you to specify default values for fields which are used in the event a value is not provided in a given document.\r\nA default can either be specified as literal:\r\n```python\r\nschema = Schema({\"num_wheels\": {\"type\": int, \"default\": 4}})\r\n```\r\nor as a reference to parameterless function which will be called at the point the document is saved:\r\n```python\r\nimport datetime\r\nschema = Schema({\"created_date\": {\"type\": datetime, \"default\": datetime.now}})\r\n```\r\n\r\n### Validation\r\nMongothon allows you to specify validation for a field using the `\"validates\"` key in the field spec.\r\nYou can specify a single validator:\r\n```python\r\nschema = Schema({\"color\": {\"type\": basestring, \"validates\": one_of(\"red\", \"green\", \"blue\")}})\r\n```\r\nor multiple validators:\r\n```python\r\nschema = Schema({\"num_wheels\": {\"type\": int, \"validates\": [gte(0), lte(6)]}})\r\n```\r\n\r\n#### Provided validators\r\nMongothon provides the following validators out-of-the-box:\r\n```python\r\n# Validator                         # Validates that the field...\r\ngte(value)                          # is greater than or equal to the given value\r\nlte(value)                          # is less than or equal to the given value\r\ngt(value)                           # is greater than the given value\r\nlt(value)                           # is less than the given value\r\nbetween(min_value, max_value)       # is between the given min and max values\r\nlength(min_length, [max_length])    # is at least the given min length and (optionally) at most the given max length\r\nmatch(pattern)                      # matches the given regex pattern\r\none_of(values...)                   # is equal to one of the given values\r\nis_url()                            # is a valid URL\r\nis_email()                          # is a valid email address\r\n```\r\n\r\n#### Creating custom validators\r\nIn addition to the provided validators it's easy to create your own custom validators.\r\nTo create a custom validator:\r\n - declare a function which accepts any arguments you want to provide to the validation algorithm\r\n - the function should itself return a function which will ultimately be called by Mongothon when validating a field value. The function should:\r\n    - accept a single argument - the field value being validated\r\n    - return nothing if the given value is valid\r\n    - return a string describing the validation error if the value is invalid\r\n\r\nHere's the declaration of an example custom validator:\r\n```python\r\ndef startswith(prefix):\r\n    def validate(value):\r\n        if not value.startswith(prefix):\r\n            return \"String must start with %s\" % prefix\r\n\r\n# Usage:\r\nschema = Schema({\"full_name\": {\"type\": basestring, \"validates\": startswith(\"Mr\")}})\r\n```\r\n\r\n### Nested schemas\r\nSchemas may be nested within one another in order to describe the structure of documents containing deep graphs.\r\n\r\nNested can either be declared inline:\r\n```python\r\nblog_post_schema = Schema({\r\n    \"author\":   {\"type\": Schema({\"first_name\": {\"type\": basestring}, \"last_name\": {\"type\": basestring}})},\r\n    \"title\":    {\"type\": basestring},\r\n    \"content\":  {\"type\": basestring}\r\n})\r\n\r\n```\r\nor declared in isolation and then referenced (and potentially reused between multiple parent schemas):\r\n```python\r\nname_schema = Schema({\r\n    \"first_name\":   {\"type\": basestring},\r\n    \"last_name\":    {\"type\": basestring}\r\n})\r\n\r\nblog_post_schema = Schema({\r\n    \"author\":   {\"type\": name_schema},\r\n    \"title\":    {\"type\": basestring},\r\n    \"content\":  {\"type\": basestring}\r\n})\r\n\r\ncomment_schema = Schema({\r\n    \"author\":   {\"type\": name_schema, \"required\":True},\r\n    \"comment\":  {\"type\": base_string}\r\n})\r\n\r\n```\r\nIn each case the nested schema is provided as the `type` parameter in the parent field's spec and can be declared as `\"required\"=True` if so desired. Any validation present within the nested schema is applied wherever the schema\r\nis used.\r\n\r\n\r\n### Embedded collections\r\nAs well as nesting schemas directly under fields, Mongothon supports embedded collections within documents. To declare an embedded collection, simply declare the type of the embedded items using Python list syntax:\r\n```python\r\nline_item_schema = Schema({\r\n    \"price\":        {\"type\": int, \"required\": True}\r\n    \"item_name\":    {\"type\": basestring, \"required\": True}\r\n})\r\n\r\norder_schema = Schema({\r\n    \"line_items\":   [line_item_schema]\r\n    \"total_due\":    {\"type\": int}\r\n})\r\n```\r\nSimple primitive types can be embedded as well as full schemas:\r\n```python\r\nbookmark_schema = Schema({\r\n    \"url\":      {\"type\": basestring},\r\n    \"tags\":     [basestring]\r\n})\r\n```\r\n\r\n## Models\r\nWhere Schemas are used to declare the structure and constraints of a Mongo document, Models allow those Schemas to be used in interacting with the database to enforce that document structure.\r\n\r\n### Creating a model class\r\nTo create a new model class from an existing schema, use the `create_model` method:\r\n```python\r\nOrder = create_model(order_schema, db['orders'])\r\n```\r\nThe second argument which must be provided to `create_model` is the PyMongo collection object associated with the underlying MongoDB collection to be associated with the model.\r\n\r\n### Class methods\r\nModel classes provide a number of class methods which can be used to interact with the underlying collection as a whole.\r\n\r\n#### Finding documents\r\nModel classes can be used to find individual documents by ID:\r\n```python\r\norder = Order.find_by_id(some_id)  # returns an instance of Order\r\n```\r\nor using a search condition:\r\n```python\r\norder = Order.find_one({'total_due': {'$gte': '10'}})  # returns an instance of Order\r\n```\r\nSelections of documents can also be retrieved using search criteria:\r\n```python\r\norder = Order.find({'total_due': {'$gte': '10'}})  # returns a cursor containing Order instances\r\n```\r\n\r\n#### Updating documents\r\nModel classes can be used to perform updates on the collection:\r\n```python\r\nOrder.update({'total_due': {'$gte': '10'}}, {'$unset': {'line_items': 1}})\r\n```\r\n\r\n#### Counting items\r\n```python\r\nOrder.count()\r\n```\r\n\r\n#### Custom class methods\r\nYou can dynamically add custom class methods to your model by using the model's `class_method` decorator function. These are useful for adding custom finder methods to your model:\r\n\r\n```python\r\n@BlogPost.class_method\r\ndef find_by_author(cls, author):\r\n    return cls.find({\"author\": author})\r\n\r\nposts = BlogPost.find_by_author(\"Jeff Atwood\")\r\n```\r\n\r\n\r\n### Instance methods\r\nInstances of models allow documents to be easily created, manipulated, save and deleted.\r\n\r\n#### Creating documents\r\nCreate a new instance of a model by passing the document as a Python dict into the constructor:\r\n```python\r\norder = Order({\r\n    \"line_items\": [\r\n        {\"item_name\": \"iPhone 5\", \"price\": 200},\r\n        {\"item_name\": \"Mac Mini\", \"price\": 500}\r\n    ],\r\n    \"total_due\": 700\r\n})\r\n```\r\n\r\n#### Saving documents\r\nIn order to persist document changes to the DB, the model can be saved:\r\n```python\r\norder.save()\r\n```\r\nSaving an existing, previously loaded document will cause it to be updated. Saving a new document will cause it to be inserted.\r\nIn all cases, saving a document results in schema defaults being applied where appropriate and the document being validated before it is saved to the database. In the event of a validation failure `save()` will raise a ValidationException.\r\n\r\n#### Deleting documents\r\nA document may be removed from the underlying collection by calling the `remove()` method on the associated model instance:\r\n```python\r\norder = Order.find_by_id(some_id)\r\norder.remove()  # document is removed from the DB\r\n```\r\n\r\n#### Reload\r\nYou can easily reload a model instance from the database by calling the `reload` method on an instance:\r\n```python\r\norder = Order.find_by_id(some_id)\r\n...\r\norder.reload()\r\n```\r\n\r\n\r\n#### Custom instance methods\r\nCustom instance methods can be added to a model using the model's `instance_method` decorator. This comes in useful when you want to wrap up common operations on a document:\r\n\r\n```python\r\n@Order.instance_method\r\ndef add_line_item(self, name, price):\r\n    self.line_items.append({'item_name': name, 'price': price})\r\n\r\norder = Order.find_by_id(some_id)\r\norder.add_line_item(\"iPad Mini\", 300)\r\norder.save()\r\n```\r\n\r\n### \"Scopes\" (beta)\r\n\r\nScopes are a dynamic way of attaching reusable sets of query options to a model which can then be chained together dynamically in order to run actual queries against the model's underlying collection.\r\n\r\nFor example:\r\n```python\r\n@Order.scope\r\ndef before(date):\r\n    return {\"created_date\": {\"$lt\": date}}\r\n\r\n@Order.scope\r\ndef single_item():\r\n    return {\"items\": {\"$size\": 1}}\r\n\r\n# Obtains a list of orders which were created before 20120101 which have a single line item.\r\norders = Order.before(datetime(2012, 1, 1)).single_item().execute()\r\n```\r\n\r\n#### Implementing scope functions\r\n\r\nA \"scope\" function is simply a function which returns up to three return values:\r\n - A query dict\r\n - A projection dict\r\n - An options dict, containing a list of kwargs suitable for passing to PyMongo's `find` method.\r\n\r\nA scope is registered with a given model by using the model's `scope` decorator.\r\n\r\nSome example scopes:\r\n```python\r\n@BlogPost.scope\r\ndef author(name):\r\n    \"\"\"A scope which restricts the query to only blog posts by the given author\"\"\"\r\n    return {\"name\": name}\r\n\r\n@BlogPost.scope\r\ndef id_only():\r\n    \"\"\"Only return the ID from the query\"\"\"\r\n    return {}, {\"_id\": 1}\r\n\r\n@BlogPost.scope\r\ndef by_created_date():\r\n    \"\"\"Sorts the query results by created date\"\"\"\r\n    return {}, {}, {\"sort\": [\"created_date\", 1]}\r\n```\r\n\r\n#### Using scopes\r\n\r\nScope functions, once registered to a given model, can be called on the model class to dynamically build up a query context in a chainable manner.\r\n\r\nOnce the query context has been built it can be executed as an actual query against the database by calling `execute()`.\r\n\r\n```python\r\n# Finds all BlogPosts with a given author, only returning their IDs\r\nposts = BlogPost.author(\"bob\").id_only().execute()\r\n```\r\n\r\nThe builder API which allows scopes to be chained together in this manner also implements a Python iterator which will call `execute()` behind the scenes if you attempt to index into it:\r\n\r\n```python\r\nfor post in BlogPost.author(\"bob\").id_only():\r\n    # Do something\r\n```\r\n\r\n### Middleware\r\n\r\nModels allow you to register middleware functions which will be passed flow control at various specific points in the lifecycle of a model.\r\n\r\nCurrently supported middleware events are:\r\n\r\n`before_save` - called just before a document is saved\r\n`after_save` - called just after a document is saved\r\n`before_validate` - called just before a document is validated\r\n`after_validate` - called just after a document is validated\r\n\r\nIn each case the registered middleware function will be passed the document object.\r\n\r\nExample:\r\n```python\r\ndef log_saved(doc):\r\n    logging.info(\"Saved order {0}\", doc._id)\r\n\r\n# Register the function\r\nOrder.after_save(log_saved)\r\n```\r\nThere is no limit to the number of middleware functions which can be registered.\r\n\r\n\r\n### Model State\r\n\r\nMongothon models provide a few handy methods which let you determine the document's current persistence state:\r\n\r\n```python\r\npost = BlogPost()\r\nassert post.is_new()\r\n\r\npost.save()\r\nassert not post.is_new()\r\nassert post.is_persisted()\r\n\r\npost.remove()\r\nassert not post.is_new()\r\nassert not post.is_persisted()\r\nassert port.is_deleted()\r\n```\r\n\r\n# Developing and Contributing\r\n\r\nTo run Mongothon's tests, simply run `python setup.py nosetests` at the command line.\r\n\r\nAll contributions submitted as GitHub pull requests are warmly received.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}