{"name":"Mongothon","tagline":"A lightweight Mongo object-document mapping abstraction layer over PyMongo","body":"# Mongothon\r\n\r\nMongothon is a MongoDB object-document mapping API for Python, loosely based on the awesome [mongoose.js](http://mongoosejs.com/) library.\r\n\r\n[![build status](https://travis-ci.org/gamechanger/mongothon.png?branch=master \"Build status\")](https://travis-ci.org/gamechanger/mongothon)\r\n\r\n# Installation\r\n\r\nInstall via easy_install:\r\n```\r\neasy_install mongothon\r\n```\r\nOr, via pip:\r\n```\r\npip install mongothon\r\n```\r\n\r\n# Getting Started\r\n\r\nMongothon allows you to couple reusable schemas (based on the [Schemer](http://github.com/gamechanger/schemer) API) with Model classes which can be used in your application to perform IO with your associated Mongo collection.\r\n\r\n## Example\r\n\r\nDefine the Mongo document structure and constraints in a Schema:\r\n```python\r\nfrom mongothon import Schema\r\n\r\ncar_schema = Schema({\r\n    \"make\":         {\"type\": basestring, \"required\": True},\r\n    \"model\":        {\"type\": basestring, \"required\": True},\r\n    \"num_wheels\":   {\"type\": int,        \"default\": 4, \"validates\": gte(0)}\r\n    \"color\":        {\"type\": basestring, \"validates\": one_of(\"red\", \"green\", \"blue\")}\r\n})\r\n```\r\n\r\nGenerate a reusable model class from the Schema and pymongo collection:\r\n```python\r\nCar = create_model(car_schema, db['car'])\r\n```\r\n\r\nFind, modify and save a document:\r\n```python\r\ncar = Car.find_by_id(some_id)\r\ncar['color'] = \"green\"\r\ncar.save()\r\n```\r\n\r\nCreate a new document:\r\n```python\r\ncar = new Car({\r\n    \"make\":     \"Ford\",\r\n    \"model\":    \"F-150\",\r\n    \"color\":    \"red\"\r\n})\r\ncar.save()\r\n```\r\n\r\nRemove a document\r\n```python\r\ncar.remove()\r\n```\r\n\r\nValidate a document\r\n```python\r\ncar = new Car({\r\n    \"make\":         \"Ford\",\r\n    \"model\":        \"F-150\",\r\n    \"num_wheels\":   -1\r\n    \"color\":        \"red\"\r\n})\r\n\r\ntry:\r\n    car.validate()\r\nexcept ValidationException:\r\n    # num_wheels should be >= 0\r\n\r\n```\r\n\r\n# API Reference\r\n\r\n## Schemas\r\n\r\nSchemas in Mongothon are based almost completely on the Schema class provided by the [Schemer](http://github.com/gamechanger/schemer) library. Take a look at the [Schemer](http://github.com/gamechanger/schemer) docs for details of how to describe your document's structure, validation rules and defaults.\r\n\r\nFor convenience, Mongothon offers it's own `Schema` subclass which includes standard Schemer functionality but adds support for Mongo \"_id\" fields.\r\n\r\n## Models\r\nWhere Schemas are used to declare the structure and constraints of a Mongo document, Models allow those Schemas to be used in interacting with the database to enforce that document structure.\r\n\r\n### Creating a model class\r\nTo create a new model class from an existing schema, use the `create_model` method:\r\n```python\r\nOrder = create_model(order_schema, db['orders'])\r\n```\r\nThe second argument which must be provided to `create_model` is the PyMongo collection object associated with the underlying MongoDB collection to be associated with the model.\r\n\r\n### Class methods\r\nModel classes provide a number of class methods which can be used to interact with the underlying collection as a whole.\r\n\r\n#### Finding documents\r\nModel classes can be used to find individual documents by ID:\r\n```python\r\norder = Order.find_by_id(some_id)  # returns an instance of Order\r\n                                   # or throws NotFoundException\r\n```\r\nor using a search condition:\r\n```python\r\norder = Order.find_one({'total_due': {'$gte': '10'}})  # returns an instance of Order\r\n```\r\nSelections of documents can also be retrieved using search criteria:\r\n```python\r\norder = Order.find({'total_due': {'$gte': '10'}})  # returns a cursor containing Order instances\r\n```\r\n\r\n#### Updating documents\r\nMongothon two mechanisms to run updates against documents.\r\n\r\n##### `Model.update` (static method)\r\nThe class method version of `update` is essentially a proxy for the underlying Pymongo collection object's `update` method and can be\r\ncalled as such.\r\n```python\r\nOrder.update({'total_due': {'$gte': 700}}, {'$unset': {'line_items': 1}})\r\n```\r\n\r\n##### `model.update_instance` (instance method)\r\nThe instance method `update_instance` makes it easy to run an update statement against the current model document by defaulting the `query` used to `{'_id': self['_id']}`.\r\n```python\r\norder = Order.find_by_id(some_id)\r\norder.update_instance({'$unset': {'line_items': 1}})\r\n```\r\n\r\n###### Note\r\n`model.update` (instance method) will delegate to python's dictionary API:\r\n```python\r\norder = Order.find_by_id(some_id)\r\norder.update({'line_items': 1})\r\nprint order['line_items']  # 1\r\n```\r\n\r\n#### Counting items\r\n```python\r\nOrder.count()\r\n```\r\n\r\n#### Custom class methods\r\nYou can dynamically add custom class methods to your model by using the model's `class_method` decorator function. These are useful for adding custom finder methods to your model:\r\n\r\n```python\r\n@BlogPost.class_method\r\ndef find_by_author(cls, author):\r\n    return cls.find({\"author\": author})\r\n\r\nposts = BlogPost.find_by_author(\"Jeff Atwood\")\r\n```\r\n\r\n\r\n### Instance methods\r\nInstances of models allow documents to be easily created, manipulated, save and deleted.\r\n\r\n#### Creating documents\r\nCreate a new instance of a model by passing the document as a Python dict into the constructor:\r\n```python\r\norder = Order({\r\n    \"line_items\": [\r\n        {\"item_name\": \"iPhone 5\", \"price\": 200},\r\n        {\"item_name\": \"Mac Mini\", \"price\": 500}\r\n    ],\r\n    \"total_due\": 700\r\n})\r\n```\r\n\r\n#### Validating documents\r\nYou can validate a document against its Schema by simply calling `validate` on the document instance:\r\n```python\r\norder.validate()  # raises a ValidationException is the document is invalid\r\n```\r\n\r\n#### Saving documents\r\nIn order to persist document changes to the DB, the model can be saved:\r\n```python\r\norder.save()\r\n```\r\nSaving an existing, previously loaded document will cause it to be updated. Saving a new document will cause it to be inserted.\r\nIn all cases, saving a document results in schema defaults being applied where appropriate and the document being validated before it is saved to the database. In the event of a validation failure `save()` will raise a ValidationException.\r\n\r\n#### Deleting documents\r\nA document may be removed from the underlying collection by calling the `remove()` method on the associated model instance:\r\n```python\r\norder = Order.find_by_id(some_id)\r\norder.remove()  # document is removed from the DB\r\n```\r\n\r\n#### Reload\r\nYou can easily reload a model instance from the database by calling the `reload` method on an instance:\r\n```python\r\norder = Order.find_by_id(some_id)\r\n...\r\norder.reload()\r\n```\r\n\r\n\r\n#### Custom instance methods\r\nCustom instance methods can be added to a model using the model's `instance_method` decorator. This comes in handy when you want to wrap up common operations on a document:\r\n\r\n```python\r\n@Order.instance_method\r\ndef add_line_item(self, name, price):\r\n    self.line_items.append({'item_name': name, 'price': price})\r\n\r\norder = Order.find_by_id(some_id)\r\norder.add_line_item(\"iPad Mini\", 300)\r\norder.save()\r\n```\r\n\r\n### \"Scopes\" (beta)\r\n\r\nScopes are a dynamic way of attaching reusable sets of query options to a model which can then be chained together dynamically in order to run actual queries against the model's underlying collection.\r\n\r\nFor example:\r\n```python\r\n@Order.scope\r\ndef before(date):\r\n    return {\"created_date\": {\"$lt\": date}}\r\n\r\n@Order.scope\r\ndef single_item():\r\n    return {\"items\": {\"$size\": 1}}\r\n\r\n# Obtains a list of orders which were created before 20120101 which have a single line item.\r\norders = Order.before(datetime(2012, 1, 1)).single_item()\r\n```\r\n\r\n#### Combining queries with nested criteria\r\n\r\nWhen dealing with multiple chained scopes, Mongothon uses a \"deep merge, last query wins\" approach to combine multiple query dicts into a single query dicts. This ensures that queries with nested query elements may be combined just as easily as simple key-value queries.\r\n\r\nExamples:\r\n```python\r\n@Order.scope\r\ndef item_priced_lt(price):\r\n    return {\"items\": {\r\n        \"$elemMatch\": {\r\n            \"price\": {\"$lt\": price}\r\n        }\r\n    }}\r\n\r\n@Order.scope\r\ndef item_priced_gt(price):\r\n    return {\"items\": {\r\n        \"$elemMatch\": {\r\n            \"price\": {\"$gt\": price}\r\n        }\r\n    }}\r\n\r\n@Order.scope\r\ndef item_named(name:\r\n    return {\"items\": {\r\n        \"$elemMatch\": {\r\n            \"name\": name\r\n        }\r\n    }}\r\n\r\norders = Order.item_named('iPhone').item_priced_lt(500).item_priced_gt(200)\r\n\r\n# Resultant query:\r\n#   {\"items\": {\r\n#       \"$elemMatch\": {\r\n#           \"name\": \"iPhone\",\r\n#           \"price\": {\"$gt\": 200, \"$lt\": 500}\r\n#       }\r\n#   }}\r\n\r\n```\r\n\r\nOther notes:\r\n - If you have multiple queries specifying a list of values (e.g. as part of an $in statement) for the same field, Mongothon will combine the two lists for you. `{'tags': {'$in': ['red', 'blue']}` + `{'tags': {'$in': ['green', 'blue']}` => `{'tags': {'$in': ['red', 'blue', 'green']}`\r\n - Even with deep merging, if you attempt to combine two queries which specify different values for matching a field, the last scope in the chain will win.\r\n\r\n#### Implementing scope functions\r\n\r\nA \"scope\" function is simply a function which returns up to three return values:\r\n - A query dict\r\n - A projection dict\r\n - An options dict, containing a list of kwargs suitable for passing to PyMongo's `find` method.\r\n\r\nA scope is registered with a given model by using the model's `scope` decorator.\r\n\r\nSome example scopes:\r\n```python\r\n@BlogPost.scope\r\ndef author(name):\r\n    \"\"\"A scope which restricts the query to only blog posts by the given author\"\"\"\r\n    return {\"name\": name}\r\n\r\n@BlogPost.scope\r\ndef id_only():\r\n    \"\"\"Only return the ID from the query\"\"\"\r\n    return {}, {\"_id\": 1}\r\n\r\n@BlogPost.scope\r\ndef by_created_date():\r\n    \"\"\"Sorts the query results by created date\"\"\"\r\n    return {}, {}, {\"sort\": [\"created_date\", 1]}\r\n```\r\n\r\n#### Using scopes\r\n\r\nScope functions, once registered to a given model, can be called on the model class to dynamically build up a query context in a chainable manner.\r\n\r\nOnce the query context has been built up, it will executed as soon as the caller attempts to access the results.\r\n\r\n```python\r\n# Finds all BlogPosts with a given author, only returning their IDs\r\nposts = BlogPost.author(\"bob\").id_only()\r\n\r\n# The actual query is only executed against Mongo when we attempt access\r\nfirst = posts[0]\r\n```\r\n\r\nThe builder API which allows scopes to be chained together in this manner implements the Python iterator protocol as well:\r\n\r\n```python\r\nfor post in BlogPost.author(\"bob\").id_only():\r\n    # Do something\r\n```\r\n\r\nYou can call any pymongo `Cursor` method via the scope builder:\r\n\r\n```python\r\nnum_posts_by_bob = BlogPost.author(\"bob\").count()\r\n\r\nten_posts_by_bob = BlogPost.author(\"bob\").limit(10)\r\n```\r\n\r\nFurthermore, scopes can be further refined even after you have performed access on them:\r\n\r\n```python\r\nposts = BlogPost.author('bob')\r\nprint \"Bob has written a total of {} posts\".format(posts.count())\r\n\r\ngardening_posts = posts.tagged('gardening')\r\nprint \"{} of these are about gardening\".format(gardening_posts.count())\r\n```\r\n\r\n### Events\r\n\r\nMongothon Models emit events at various points in the lifecycle of a model instance. You can register one or more handler functions for a given event against the model class. These functions are then invoked at the point a model instance emits the event.\r\n\r\nTo register a function to receive an event, use the `on` model class method, either by calling it directly passing your handler function, or as a decorator:\r\n\r\n```python\r\n\r\ndef log_save(blog_post):\r\n    logging.info('Blog post {} was saved!'.format(blog_post['_id']))\r\n\r\n# Register the handler function\r\nBlogPost.on('did_save', log_save)\r\n\r\n...\r\n\r\n@BlogPost.on('did_save')\r\ndef log_save(blog_post):\r\n    logging.info('Blog post {} was saved!'.format(blog_post['_id']))\r\n```\r\n\r\n#### Implementing handler functions\r\n\r\nA valid event handler function should always expect to receive:\r\n - the model instance from which the event is being emitted as it's first argument\r\n - any other specific arguments associated with the given event (see below for a list of standard events and their additional arguments).\r\n\r\n```python\r\n@BlogPost.on('did_remove')\r\ndef log_remove(blog_post, *args, **kwargs):\r\n    logging.info('Blog post {} was removed!'.format(blog_post['_id']))\r\n\r\n@BlogPost.on('did_update')\r\ndef log_update(blog_post, document, *args, **kwargs):\r\n    logging.info('Blog post {} was updated using document'.format(blog_post['_id'], document))\r\n\r\n```\r\n\r\nWhen emitting custom events (see below for more details), this allows essentially any arguments to be passed to all handlers registered for that event.\r\n\r\n```python\r\n@BlogPost.on('archived')\r\ndef log_archived(blog_post, archived_by):\r\n    logging.info('Blog post {} was archived by {}'.format(blog_post['_id'], archived_by))\r\n\r\n...\r\n\r\ndef archive_blog_post(post_id, user_email):\r\n    blog_post = BlogPost.find_by_id(post_id)\r\n    blog_post['archived'] = True\r\n    blog_post.save()\r\n    blog_post.emit('archived', archived_by=user_email)\r\n```\r\n\r\n#### Standard events\r\n\r\nEvery Mongothon model emits the following events as part of its lifecycle:\r\n\r\n| Event | Additional args | Description |\r\n| ----- | --------------- | ----------- |\r\n| `'did_init'` | None | Emitted whenever a new model object instance is initialized. |\r\n| `'did_find'` | None | Emitted when a model object is instantiated as the result of database lookup. Fires after `'did_init'`. |\r\n| `'will_validate`' | `working` - the working copy of the `Model` instance. | Emitted just before a model is validated against it's schema. |\r\n| `'did_validate`' | `working` - the working copy of the `Model` instance. | Emitted just after a model is validated against it's schema. |\r\n| `'will_apply_defaults'` | None | Emitted just before defaults (from the associated schema) are applied to the `Model` instance .|\r\n| `'did_apply_defaults'` | None | Emitted just after defaults (from the associated schema) are applied to the `Model` instance .|\r\n| `'will_save'` | `working` - the working copy of the `Model` instance. | Emitted just before a model is saved to the database. Fires _after_ validation (and it's associated events). |\r\n| `'did_save'` | None | Emitted just after a model is saved to the database. |\r\n| `'will_update'` | All arguments provided to `update_instance()`. | Emitted just before an `update` is performed for the given model instance. |\r\n| `'did_update'` | All arguments provided to `update_instance()`. | Emitted just after an `update` is performed for the given model instance. |\r\n| `'will_remove'` | All arguments provided to `remove()`. | Emitted just before an `remove` is performed for the given model instance. |\r\n| `'did_remove'` | All arguments provided to `reomve()`. | Emitted just after an `remove` is performed for the given model instance. |\r\n\r\n\r\n##### Working copy event arguments\r\n\r\n`'will_validate'`, `'did_validate'` and `'will_save'` events include a `working` argument which is a working copy of the model instance. To properly understand what this argument is, it is useful to think about the steps Mongothon goes through when saving a Mongothon `Model` instance:\r\n\r\n1. A working (deep) copy of the model instance is created.\r\n2. Any schema default values are applied to the working copy, without affecting the primary object instance.\r\n3. The working copy is validated against the model's schema.\r\n4. If validation passes, an attempt is made to save the working copy to the underlying database collection.\r\n5. If the database save operation succeeds, the working copy is merged back into the primary object instance so that it reflects the document in the collection.\r\n\r\nSo for these events which receive the `working` argument, depending on the model's schema it is possible that this object may contain different values to the primary model instance.\r\n\r\nAlso note that if you want to implement any universal \"pre-save\" updates to the model just before it is saved (e.g. updating a 'modified' timestamp), you can do this simply by manipulating the working copy.\r\n\r\n#### Emitting custom events\r\n\r\nAs well as the standard set of events listed above which are emitted by models, it's also possible to use the `Model` event bus for any custom events you want to emit.\r\n\r\nTo emit a custom event, just invoke `emit` on a give  model instance passing a string to identify the type of event, along with any custom arguments which are relevant to that event.\r\n\r\n(Note that you don't need to pass the model instance itself as an argument to `emit`).\r\n\r\n```python\r\npost = BlogPost.find_by_id(post_id)\r\npost.emit('loaded', datetime.utcnow())\r\n```\r\n\r\nGenerally speaking, rather than emitting events directly from your model-consuming code, a better pattern is to implement an `@instance_method` on your `Model` which wraps up some operation and emit an event from within that method.\r\n\r\nTo handle a custom event, just register a handler function in the same way you would for a standard event:\r\n\r\n```python\r\nBlogPost.on('loaded')\r\ndef log_load(post, loaded_time):\r\n    logging.debug('Loaded post {} at {}'.format(post['_id'], loaded_time))\r\n```\r\n\r\n\r\n### Model State\r\n\r\nMongothon models provide a few handy methods which let you determine the document's current persistence state:\r\n\r\n```python\r\npost = BlogPost()\r\nassert post.is_new()\r\n\r\npost.save()\r\nassert not post.is_new()\r\nassert post.is_persisted()\r\n\r\npost.remove()\r\nassert not post.is_new()\r\nassert not post.is_persisted()\r\nassert port.is_deleted()\r\n```\r\n\r\n# Developing and Contributing\r\n\r\nTo run Mongothon's tests, simply run `python setup.py nosetests` at the command line.\r\n\r\nAll contributions submitted as GitHub pull requests are warmly received.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}